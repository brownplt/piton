open paranoidServer

sig ContinueServer in CapServer {
	new,create,fetch,give:Nonce,
	users:set Nonce,
	passwords:set Nonce,
	studies:set Nonce,
	data:set Nonce,
	userPassword:Nonce -> Nonce,
	userStudies:Nonce -> set Nonce,
	studyData:Nonce -> Nonce
}
fact {
	all c:ContinueServer {
		all o:CapServer {
			o.location = c.location implies {
				o in ContinueServer
				o.new = c.new
				o.create = c.create
				o.fetch = c.fetch
				o.give = c.give
			}
		}
		disj[c.users,c.passwords,c.studies,c.data]

		c.passwords in c.ownedCaps
		c.data in c.ownedCaps

		CryptographicGrants[c.location]
	
		//it knows nothing at time 0
		(c.step = Zero) implies
		(no c.knownCaps and no c.ownedCaps and no c.implementation)

		all a,b:Nonce {
			a -> b in c.userPassword implies a in c.users and b in c.passwords
			a -> b in c.userStudies implies a in c.users and b in c.studies
			a -> b in c.studyData implies a in c.studies and b in c.data
		}

		//fetch doesn't change the implementation, so it can be defined here
		all name,study:Nonce {
			name in c.users and study in c.studies implies {
				some ns,res:NonceSet {
					0 -> c.userPassword[name] + 1 -> study = ns.nonces
					0 -> c.studyData[study] = res.nonces
					c.fetch -> ns -> res in c.implementation iff name -> study in c.userStudies
				}
			}
		}
	}

	all invoker,invoker':CapServer,invokee,invokee':ContinueServer,n:Nonce,ns:NonceSet {
		//all invokes must be sent to the continue server
		//this does two things - it prevents the continue server from invoking nonces on others,
		//which it shouldn't do
		//additionally, it prevents secondary servers from talking to each other, which could
		//leak protected nonces without the continue server being at fault
		invoke[invoker,invoker',invokee,invokee',n,ns] implies {
			!(invoker in ContinueServer)

			//the continue server only responds to new, create, fetch, or give nonces
			n = invokee.new or n = invokee.create or n = invokee.fetch or n = invokee.give

			//implementation of new - creates a new user with a given name, returns his unique id
			n = invokee.new implies {
				one ns.nonces
				!(ns.nonces[0] in invokee.users)
				some secure:Nonce, secureS:NonceSet {
					secureS.nonces = 0 -> secure
					!(secure in invokee.ownedCaps)
					ns.nonces[0] -> secure in invokee'.userPassword
					invokee'.implementation = invokee.implementation + (invokee.new -> ns -> secureS)
				}
			}
			
			//implementation of create - makes a new study with a given name
			//the content is a random nonce generated by the Continue server
			//first arg is user's password, the second arg is the name of the study
			n = invokee.create implies {
				some user,password,study,secure:Nonce,secureS:NonceSet {
					ns.nonces = (0 -> password) + (1 -> study)
					user -> password in invokee.userPassword
					!(secure in invokee.ownedCaps)
					secure in invokee'.data
					!(study in invokee.studies)
					study -> secure in invokee'.studyData
					user -> study in invokee'.userStudies
					secureS.nonces = 0 -> secure
					invokee'.implementation = (invokee.implementation + 
					                           invokee.create -> ns -> secureS)					
				}
			}
			//implementation of give - first arg is user's password
			//the second arg is the name of the study
			//the third arg is the name of the recipient
			n = invokee.give implies {
				some user,password,newUser,study:Nonce,empty:NonceSet {
					no empty.nonces
					ns.nonces = (0 -> password) + (1 -> newUser) + (2 -> study)
					user -> password in invokee.userPassword
					user -> study in invokee.userStudies
					!(newUser -> study in invokee.userStudies)
					newUser -> study in invokee'.userStudies
					invokee'.implementation = (invokee.implementation + 
					                           invokee.create -> ns -> empty)
				}
			}
		}
	}
}

//any two new invokes get different responses
assert NewResponsesDifferent {
	all continue,continue',continue'':ContinueServer,server1,server1',server2,server2':CapServer,
	    ns,ns1:NonceSet {
		(invoke[server1,server1',continue,continue',continue.new,ns] and
	   invoke[server2,server2',continue',continue'',continue.new,ns1]) implies {
			not continue'.implementation[continue.new,ns] = continue''.implementation[continue.new,ns1]
			one continue'.implementation[continue.new,ns]
			one continue''.implementation[continue.new,ns1]
		}
	}
}

check NewResponsesDifferent for 6
